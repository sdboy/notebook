# 1 数据结构绪论

## 1.4 基本概念和术语

### 1.4.1 数据
数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别并输入给计算机处理的符号合集。

### 1.4.2 数据元素
数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。

### 1.4.3 数据项
数据项：一个数据元素可以由若干个数据项组成。<br>
人是数据元素，人由眼睛、耳朵、手脚等等这些数据项组成。<br>
数据项是不可分割的最小单位。<br>

### 1.4.4 数据对象
数据对象是性质相同的数据元素的集合，是数据的子集。<br>
人类是数据对象，人类由所有人组成。<br>

### 1.4.5 数据结构
不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。<br>
数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。<br>

## 1.5 逻辑结构和物理结构

逻辑结构面向问题，物理结构面向计算机。<br>

### 1.5.1 逻辑结构

逻辑结构：是指数据对象中数据元素之间的相互关系。<br>

1. **集合结构**<br>
集合结构：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。<br>
```mermaid

flowchart TD
  subgraph collection[集合结构]
A@{ shape: circle, label: "1" }
B@{ shape: circle, label: "6" }
C@{ shape: circle, label: "2" }
D@{ shape: circle, label: "4" }
E@{ shape: circle, label: "5" }
F@{ shape: circle, label: "3" }
  end
```

2. **线性结构**<br>
线性结构：线性结构中的数据元素之间是一对一的关系。<br>
```mermaid
flowchart LR
  A@{ shape: circle, label: "1" }
  B@{ shape: circle, label: "2" }
  C@{ shape: circle, label: "3" }
  D@{ shape: circle, label: "4" }
  E@{ shape: circle, label: "5" }
  F@{ shape: circle, label: "6" }

  A --- B --- C --- D --- E --- F
```

3. **树形结构**<br>
树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。<br>
```mermaid
flowchart TD
  A@{ shape: circle, label: "A" }
  B@{ shape: circle, label: "B" }
  C@{ shape: circle, label: "C" }
  D@{ shape: circle, label: "D" }
  E@{ shape: circle, label: "E" }
  F@{ shape: circle, label: "F" }
  G@{ shape: circle, label: "G" }
  H@{ shape: circle, label: "H" }
  I@{ shape: circle, label: "I" }
  J@{ shape: circle, label: "J" }

  A --- B 
  A --- C
  A --- D
  B --- E
  B --- F
  B --- G
  C --- H
  D --- I
  D --- J
```

4. **图结构**<br>
图结构：图结构的数据元素是多对多的关系。<br>
```mermaid
flowchart LR
  A@{ shape: circle, label: "1" }
  B@{ shape: circle, label: "2" }
  C@{ shape: circle, label: "3" }
  D@{ shape: circle, label: "4" }
  E@{ shape: circle, label: "5" }
  F@{ shape: circle, label: "6" }
  G@{ shape: circle, label: "7" }

  A o--o B o--o C o--o D o--o E o--o F
  F o--o A
  A o--o G
  B o--o G
  C o--o G
  D o--o G
  E o--o G
  F o--o G
```

### 1.5.2 物理结构
物理结构：是指数据的逻辑结构在计算机中的存储形式。<br>

1. **顺序存储结构**<br>

顺序存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。<br>
```mermaid
flowchart LR
  subgraph seq1
    A@{ shape: circle, label: "1" }
  end
  subgraph seq2
    B@{ shape: circle, label: "2" }
  end
  subgraph seq3
    C@{ shape: circle, label: "3" }
  end
  subgraph seq4
    D@{ shape: circle, label: "4" }
  end
  subgraph seq5
    E@{ shape: circle, label: "5" }
  end
  subgraph seq6
    F@{ shape: circle, label: "6" }
  end
  A ~~~ B ~~~ C ~~~ D ~~~ E~~~ F
```

2. **链式存储结构**<br>

链式存储结构：是把数据元素存放在连续的存储单元里，但数据间的逻辑关系和物理关系不是一致的。<br>
```mermaid
flowchart TD
  subgraph seq1
    A@{ shape: circle, label: "1" }
  end
  subgraph seq12
    B@{ shape: circle, label: "2" }
  end
  subgraph seq3
    C@{ shape: circle, label: "4" }
  end
  subgraph seq4
    D@{ shape: circle, label: "6" }
  end
  subgraph seq53
    E@{ shape: circle, label: "5" }
  end
  subgraph seq6
    F@{ shape: circle, label: "3" }
  end
  seq1 --> seq12 --> seq3 --> seq4 --> seq53 --> seq6
  A -.-> B -.-> F -.-> C -.-> E -.-> D
```

## 1.6 数据类型

数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

### 1.6.1 数据类型的定义

在C语言中，按照取值的不同，数据类型可以分为两类：<br>
- **原子类型**<br>
  不可以再分解的基本类型、包括整型、实型、字符型。

- **结构类型**<br>
  由若干个类型组合而成，是可以再分解的。<br>

抽象是指抽取出事物具有的普遍性的本质。

### 1.6.2 抽象数据类型

抽象数据类型（Abstract Data Type，ADT）：一个数学模型及定义在该模型上的一组操作。<br>

抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。<br>

```
ADT 抽象数据类型名
Data
  数据元素之间逻辑关系的定义

Operation
  操作1
  ...
  操作n
endADT
```

## 1.7 总结

<center>
<img src="./1.7.1.svg">
</center>

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>
<center>
<img src="./1.7.2.svg">
</center>

# 2 算法

## 2.4 算法的定义

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。<br。

## 2.5 算法的特性
算法有五个基本特性：输入、输出、有穷性、确定性、可行性。<br>

### 2.5.1 输入、输出

算法具有零个或多个输入。算法至少有一个或多个输出。

### 2.5.2 有穷性

有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。<br>

### 2.5.3 确定性

确定性：算法的每一步骤都具有确定的含义，不会出现二义性。<br>

### 2.5.4 可行性

可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。<br>

## 2.6 算法设计的要求

正确性、可读性、健壮性、时间效率高和存储量低。<br>

### 2.6.1 正确性

算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反应问题的需求，能够得到问题的正确答案。<br>

大体分为四个层次：
- 算法程序没有语法错误
- 算法程序对于合法的输入数据能够产生满足要求的出结果
- 算法程序对于非法输入数据能够产生错误信息
- 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果

### 2.6.2 可读性

算法设计的另一目的是为了便于阅读、理解和交流。<br>

### 2.6.3 健壮性

当输入不合法数据时，算法能够做出相关处理，而不是发生异常或莫名其妙的结果。<br>

### 2.6.4 时间效率高和存储量低

算法应该尽量满足时间效率高和存储量低的要求。<br>

## 2.7 算法效率的度量方法

### 2.7.1 事后统计法

通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率。<br>
缺陷：
- 花费大量时间和精力
- 比较容易受硬件和软件环境影响
- 算法的测试数据设计困难

这种方法不考虑采纳。<br>

### 2.7.2 事前分析估算法

在程序编制前，依据统计方法队算法进行估量。<br>

程序在计算机上运行消耗的时间主要取决于以下因素：
- 算法采用的策略、方法
- 编译产生的代码质量
- 问题的输入规模
- 机器执行指令的速度

一个程序运行时间，依赖于算法的好坏和问题的输入规模。<br>

## 2.8 函数的渐近增长

给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。<br>

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更因该关注主项（最高阶项）的阶数。<br>

## 2.9 算法时间复杂度

### 2.9.1 时间复杂度定义

在进行算法分析时，语句宗的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况确定T(n)的数量级。算法的时间复杂度也就是算法的时间量度，记作T(n)=**O**(f(n))。他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br>

用大写**O**()来体现算法时间复杂度的记法，我们称为大**O**记法。<br>

### 2.9.2 推导大O阶方法

推导大O阶：
- 用常熟1取代运行时间中的所有加法常数。
- 再修改后的运行次数函数中，只保留最高阶项
- 如果最高阶项存在且系数不是1，则去除与整个项相乘的系数。得到的结果就是大O阶

### 2.9.3 常熟阶

不管这个常量是多少，我们都记作O(1)，而不是O(3)、O(12)等其他任何数字。

### 2.9.4 线性阶

分析算法的复杂度，关键就是要分析循环结构的运行情况。<br>

### 2.9.5 对数阶

```c
int count = 1;
while(count <= n)
{
  count *= 2;
}
```
由2^x = n得到x=log2(n)，得到时间复杂度O(log2n)。

### 2.9.6 平方阶

```c
int i, j;
for(i = 0; i < n; i++)
{
  for(j = i; j < n; j++)
  {
    printf("i=%d, j=%d\n", i, j);
  }
}
```

由于当i=0时，内循环执行了n次，当i=1时，内循环执行n-1次，当i=n-1时执行了1次...以此类推，执行的总次数为：<br>
n+n-1+n-2+...+1+0=n*(n+1)/2<br>
没有常数项，保留最高阶项得到n^2/2，去除常数项系数为O(n^2)。<br>

## 2.10 常见的时间复杂度

|执行次数|阶|非正式术语|
|:---:|:---:|:---:|
|12|O(1)|常熟阶|
|2n+3|O(n)|线性阶|
|3n^2+2n+1|O(n^2)|平方阶|
|5log2(n)+20|O(logn)|对数阶|
|2n+3nlog2(n)+19|O(nlogn)|对数线性阶|
|6n^3+2n^2+3n+4|O(n^3)|立方阶|
|2^n|O(2^n)|指数阶|

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

## 2.11 最坏情况与平均情况

平均运行时间是所有情况中最有意义的，因为他是期望的运行时间。一般在没有特殊说明的情况下，都是指最坏时间复杂度。<br>

## 2.12 算法空间复杂度

算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题规模，f(n)为语句关于n所占存储空间的函数。<br>

# 3 线性表

## 3.2 线性表的定义

线性表（List）：是具有相同类型的元素，并且按一定的次序排列的集合。<br>

```mermaid
graph LR
A@{ shape: circle, label: "1" }
B@{ shape: circle, label: "2" }
C@{ shape: circle, label: "3" }
D@{ shape: circle, label: "4" }
E@{ shape: circle, label: "5" }
F@{ shape: circle, label: "6" }
G@{ shape: circle, label: "n" }
A --> B --> C --> D --> E --> F --> G
```

除了头节点，每个节点都只有一个前驱节点，除了尾节点，每个节点都只有一个后继节点。

在复杂的线性表中，一个数据元素可以由若干个数据项组成。<br>
```c
struct student {
  int sno;
  char name[20];
  char sex;
  int age;
};
```

## 3.3 线性表的抽象数据类型

线性表的抽象数据类型ADT：<br>
```
ADT 线性表（List）

Data
  线性表的数据对象集合为{a1, a2, ..., an}，每个元素的类型均为DataType。其中，除了头节点，每个节点都只有一个前驱节点，除了尾节点，每个节点都只有一个后继节点。数据元素之间的关系是一对一。

Operation
  InitList() 初始化一个空的线性表
  DestroyList(L) 销毁线性表L
  ClearList(L) 清空线性表L
  ListEmpty(L) 判断线性表L是否为空
  ListLength(L) 返回线性表L的长度
  GetElem(L, i, *e) 返回线性表L中第i个元素的值，即e
  LocateElem(L, e) 返回线性表L中与e值相同的元素的位序，如果找不到则返回0
  ListInsert(*L, i, e) 在线性表L中第i个元素之前插入元素e
  ListDelete(*L, i, *e) 在线性表L中删除第i个元素，并返回删除元素的值

endADT
```

>注意：当你传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了使用什么参数形式。<br>
如果需要被改动，则需要传递指向这个参数的指针<br>
如果不需要被改动，可以直接传递这个参数<br>

## 3.4 线性表的顺序存储结构

### 3.4.1 顺序存储定义

线性表的顺序存储结构，指的是用一段地址连续的存储单元一次存储线性表的数据元素。<br>

<center>
<img src="3.4.1.svg">
</center>

### 3.4.2 顺序存储方式

在C语言中可以使用一维数组来实现顺序存储结构。<br>
```c
// 存储空间分配
#define MAXSIZE 100

typedef int ElemType;
typedef struct {
  // 存储数据元素
  ElemType data[MAXSIZE];
  // 线性表当前长度
  int length;
}SqList;
```

描述顺序存储结构需要三个属性：
- 存储空间的起始位置：数组data，它的存储位置就是存储空间的位置
- 线性表的最大存储容量：MAXSIZE
- 线性表的当前长度：length

### 3.4.3 数据长度和线性表长度的区别

线性表的长度是线性表当前存储的元素个数，而数据长度是线性表存储空间的长度。<br>

### 3.4.4 地址计算方法

存储器中的每个存储单元都有自己的编号，这个编号称为地址。<br>

LOC表示获得存储位置的函数。每个元素占据c个存储单元<br>

LOC(ai+1) = LOC(ai) + c<br>

LOC(ai) = LOC(a1) + (i-1)*c<br>

顺序表的存取性能为O(1)，我们通常把具有这一特点的存储结构称为随机存取结构。<br>

## 3.5 顺序存储的插入与删除

### 3.5.1 获得元素

```c
#define OK 1;
#define ERROR 0;
typedef int Status;
// 操作结构：获取L中第i个元素，数组下标从0开始
Status GetElem(SqList L, int i, ElemType *e) {
  if(L.length == 0 || i < 1 || i > L.length) 
    return ERROR;
  *e = L.data[i-1];
  return OK;
}
```

### 3.5.2 插入元素

插入算法的思路：
- 插入位置不合理抛出异常
- 如果插入后线性表的长度大于线性表最大存储容量，则抛出异常或动态增加容量
- 从最后一个元素开始向前遍历到第i个位置，分别将它们向后移动一个位置
- 将第i个位置的元素设置为e
- 线性表长度加1

```c
Status ListInsert(SqList *L, int i, ElemType e) {
  int k;
  if(L->length == MAXSIZE) 
    return ERROR;
  if(i < 1 || i > L->length+1) 
    return ERROR;
  if(i <= L->length) {
    for(k = L->length; k >= i; k--) {
      L->data[k + 1] = L->data[k];
    }
  }
  L->data[i-1] = e;
  L->length++;
  return OK;
}

```

### 3.5.3 删除元素

删除算法思路：
- 删除位置不合理抛出异常
- 取出删除元素
- 从删除位置开始遍历到最后一个元素位置，分别将它们向前移动一个位置
- 线性表长度减1

```c
Status ListDelete(SqList *L, int i, ElemType *e) {
  int k;
  if(L->length == 0 || i < 1 || i > L->length)
    return ERROR;
  *e = L->data[i-1];
  if(i < L->length) {
    for(k = i; k < L->length; k++) {
      L->data[k-1] = L->data[k];
    }
  }
  L->length--;
  return OK;
}
```

### 3.5.4 线性表顺序存储结构的优缺点

优点：
- 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速的存取表中任一位置的元素

缺点：
- 插入和删除操作需要移动大量元素，时间复杂度O(n)
- 线性表长度有限，当长度达到最大值时，无法再插入新元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的碎片化

## 3.6 线性表的链式存储结构

# 4 栈与队列

# 5 串

# 6 树

# 7 图

# 8 散列

# 9 查找

# 10 排序
